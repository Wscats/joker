# 声明方式

1、构造函数方式
```js
var reg = new RegExp('\d', 'gi');
```
2、字面量方式
```js
var reg = /\d/gi;
```

# 修饰符

修饰符有三种：`i, g, m` 可以同时出现，没有顺序（即 `gi` 与 `ig` 一样），请参考下方说明

|修饰符|说明|
|-|-|
|i|忽略大小写匹配|
|g|全局匹配，即是匹配一个后继续匹配，直到结束|
|m|多行匹配，即是遇到换行后不停止匹配，直到结束|

# 特殊字符

|符号|作用|
|-|-|
|\ |做为转意，即通常在"\"后面的字符不按原来意义解释，如/b/匹配字符"b"，当b前面加了反斜杆后/\b/，转意为匹配一个单词的边界。 或对正则表达式功能字符的还原，如"*"匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了"\"后，/a\*/将只匹配"a*"| 
|^ |匹配一个输入或一行的开头，/^a/匹配"an A"，而不匹配"An a"| 
|$ |匹配一个输入或一行的结尾，/a$/匹配"An a"，而不匹配"an A"|
|. |匹配任意单个字符，除换行和结束符|
|* |匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa|
|+ |匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa|
|? |匹配前面元字符0次或1次，/ba?/将匹配b,ba |
|(x) |匹配x保存x在名为$1...$9的变量中 |
|x|y |匹配x或y |
|{n} |精确匹配n次 |
|{n,} |匹配n次以上 |
|{n,m} |匹配n-m次 |
|[xyz] |字符集(character set)，匹配这个集合中的任一一个字符(或元字符) |
|[^xyz] |不匹配这个集合中的任何一个字符 |
|[a-z] | 任意字母 []中的表示任意一个都可以|
|[^a-z] | 非字母 []中^代表除了|
|[\b] |匹配一个退格符 |
|\b |匹配一个单词的边界 |
|\B |匹配一个单词的非边界 |
|\cX |这儿，X是一个控制符，/\cM/匹配Ctrl-M |
|\d |匹配一个字数字符，/\d/ = /[0-9]/ |
|\D |匹配一个非字数字符，/\D/ = /[^0-9]/ |
|\n |匹配一个换行符 |
|\r |匹配一个回车符 |
|\f |匹配换页符 |
|\s |匹配一个空白字符，包括\n,\r,\f,\t,\v等 |
|\S |匹配一个非空白字符，等于/[^\n\f\r\t\v]/ |
|\t |匹配一个制表符 |
|\v |匹配一个重直制表符 |
|\w |匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\w]匹配"$5.98"中的5，等于[a-zA-Z0-9] |
|\W |匹配一个不可以组成单词的字符，如[\W]匹配"$5.98"中的$，等于[^a-zA-Z0-9]|
|\0 |匹配NUL字符 |

## 零宽断言

零宽断言用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b,^,$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言

||||
|-|-|-|
|先行断言|也叫零宽度正预测先行断言`(?=表达式)`表示匹配表达式前面的位置|例如`[a-z]*(?=ing)`可以匹配cooking singing中的cook与sing|

注意：先行断言的执行步骤是这样的先从要匹配的字符串中的最右端找到第一个ing(也就是先行断言中的表达式)然后 再匹配其前面的表达式，若无法匹配则继续查找第二个ing再匹配第二个ing前面的字符串，若能匹配 则匹配

||||
|-|-|-|
|后发断言|也叫零宽度正回顾后发断言`(?<=表达式)`表示匹配表达式后面的位置|例如`(?<=abc).*`可以匹配abcdefg中的defg|

注意：后发断言跟先行断言恰恰相反 它的执行步骤是这样的：先从要匹配的字符串中的最左端找到第一个abc(也就是先行断言中的表达式)然后 再匹配其后面的表达式，若无法匹配则继续查找第二个abc再匹配第二个abc后面的字符串，若能匹配则匹配，例如`(?<=abc).*`可以匹配abcdefgabc中的defgabc 而不是abcdefg

|||
|-|-|
|负向零宽断言|`(?!表达式)`也是匹配一个零宽度的位置，不过这个位置的“断言”取表达式的反值，例如 `(?!表达式)`表示表达式前面的位置，如果表达式 不成立，匹配这个位置；如果 表达式 成立，则不匹配：同样，负向零宽断言也有“先行”和“后发”两种，负向零宽后发断言为`(?<!表达式)`|

- 负向零宽后发断言`(?<!表达式)`
- 负向零宽先行断言`(?!表达式)`
- 负向零宽断言要注意的跟正向的一样

## 编辑工具中的搜索正则

使用小括号将匹配的字符串包上，然后替换值中可以通过$1表达式来获取到当前正在匹配的值，这里可以更复杂些，比如存在多个小括号，相应的可以使用$1、$2、$3来获取对应值，全部替换后，就是我们最终想要的数据了

比如以下是在搜索框中的正则表达式，就可以把HTML结构中的所有`class`属性给匹配出来
```js
className="([^0-9]+)"
```
那我们可以在替换中
```js
className={{$1}}
```
那就会把
```js
className="xxx" //转化为
className={{xxx}}
```

# 相关方法

1、RegExp对象相关方法

|方法名|使用场景|返回值|示例|
|-|-|-|-|
|test|判断是否匹配|true或false|/\d/.test('eno yao 2019')|
|test|返回匹配的结果，与match类似|数组或null|/\d/.exec('eno yao 2019')|

2、String对象相关方法

|方法名|使用场景|返回值|示例|
|-|-|-|-|
|match|返回匹配的结果，非全局条件下与exec返回结果一致，并拥有指向匹配字符串的信息，全局条件下一次性返回所有匹配的结果|数组或null|'eno yao 2019'.match(/\d/)|
|replace|将字符串替换成另外的字符串或者将正则的匹配字符串替换成其他子串|数组或null|'eno yao 2019'.replace(/\d/, '2019')|
|search|查找第一次匹配子串的位置，返回index值，否则返回-1|index|'eno yao 2019'.search(/\d/, '2019')|
|split|按约定字符串或字符串拆分数组，接受一个字符串或正则|index|'eno yao 2019'.search(/\d/, '2019')|